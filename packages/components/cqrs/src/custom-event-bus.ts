import { IEvent, UnhandledExceptionBus, IEventHandler, ICommand, ISaga, EventBus, CommandBus } from '@nestjs/cqrs';
import { Type, Logger, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { defer, of, Subject, Observable, tap, from } from 'rxjs';
import { catchError, concatMap, filter } from 'rxjs/operators';
import { EVENTS_HANDLER_METADATA, SAGA_METADATA } from '@nestjs/cqrs/dist/decorators/constants';
import { UnhandledExceptionInfo } from '@nestjs/cqrs/dist/interfaces';
import { InvalidSagaException } from '@nestjs/cqrs/dist/exceptions/invalid-saga.exception';

export type EventHandlerType<EventBase extends IEvent = IEvent> = Type<IEventHandler<EventBase>>;

@Injectable()
export class CustomEventBus<EventBase extends IEvent = IEvent> extends EventBus<EventBase> {
  private readonly _newLogger = new Logger(CustomEventBus.name);
  private readonly _eventHandlerCompletionSubject$ = new Subject<IEvent>();
  private readonly _sagaCompletionSubject$ = new Subject<IEvent>();

  constructor(
    private readonly ingectCommandBus: CommandBus,
    private readonly injectedModuleRef: ModuleRef,
    private readonly injectedUnhandledExceptionBus: UnhandledExceptionBus
  ) {
    super(ingectCommandBus, injectedModuleRef, injectedUnhandledExceptionBus);
  }

  /**
   * Returns an Observable that allows tracking events
   * processed by the event handler.
   *
   * @returns Observable<IEvent> - An Observable that emits events after they have been processed.
   */
  get eventHandlerCompletionSubject$(): Observable<IEvent> {
    return this._eventHandlerCompletionSubject$.asObservable();
  }

  /**
   * Returns an Observable that allows tracking events
   * processed by the saga.
   *
   * @returns Observable<IEvent> - An Observable that emits events after they have been processed by the saga.
   */
  get sagaCompletionSubject$(): Observable<IEvent> {
    return this._sagaCompletionSubject$.asObservable();
  }

  async publish<T extends EventBase, TContext = unknown>(event: T, context?: TContext) {
    await this.publisher.publish(event, context);
  }

  async publishAll<T extends EventBase, TContext = unknown>(events: T[], context?: TContext) {
    // if (this.publisher.publishAll) {
    //   await this.publisher.publishAll(events, context);
    // } else {
    // await Promise.all(events.map((event) => this.publisher.publish(event, context)));
    // }
    for (const event of events) {
      await this.publisher.publish(event, context);
    }
  }

  bind(handler: IEventHandler<EventBase>, id: string) {
    // IMPORTANT: method ofEventId() filtering events by metadata id field.
    // id is a value generated by the @EventHandler() decorator,
    // that is assigned handler to a specific event type.
    // In our system we overwrite this id with own metadata as name of event constructor.
    // (The EventHandler decorator acts as a two-in-one, it is a decorator for both the EventHandler and the Event)
    // (a specific event type - this means that the handler will work using this id with all events from one class).
    // (all events of this type will have the same id).
    const stream$ = id ? this.ofEventId(id) : this.subject$;
    const subscription = stream$
      .pipe(
        concatMap((event) =>
          defer(() =>
            from(handler.handle(event)).pipe(
              // Notify about completion of processing
              tap(() => this._eventHandlerCompletionSubject$.next(event)),
              catchError((error) => {
                this._eventHandlerCompletionSubject$.error(error);
                const unhandledError = this.mapUnhandledExceptionEvent(event, error);
                this.injectedUnhandledExceptionBus.publish(unhandledError);
                return of();
              })
            )
          )
        )
      )
      .subscribe();
    this.subscriptions.push(subscription);
  }

  registerSagas(types: Type<unknown>[] = []) {
    const sagas = types
      .map((target) => {
        const metadata = Reflect.getMetadata(SAGA_METADATA, target) || [];
        // TODO: Provide the correct type
        const instance: any = this.injectedModuleRef.get(target, { strict: false });
        if (!instance) {
          throw new InvalidSagaException();
        }
        return metadata.map((key: string) => instance[key].bind(instance));
      })
      .reduce((a, b) => a.concat(b), []);

    // TODO: Provide the correct type
    sagas.forEach((saga: any) => this.registerSaga(saga));
  }

  protected registerSaga(saga: ISaga<EventBase>) {
    if (typeof saga !== 'function') {
      throw new InvalidSagaException();
    }
    const stream$ = saga(this);
    if (!(stream$ instanceof Observable)) {
      throw new InvalidSagaException();
    }

    const subscription = stream$.pipe(filter((e) => !!e)).subscribe({
      next: (data) => {
        this._newLogger.debug(`Saga result: ${data}`);
        this._sagaCompletionSubject$.next(data);
      },
      error: (error) => {
        this._newLogger.error(`Saga has thrown an unhandled exception: ${error}`);
        this._sagaCompletionSubject$.error(error);
      },
      complete: () => {
        this._newLogger.debug('Saga processing completed.');
        this._sagaCompletionSubject$.complete();
      },
    });

    this.subscriptions.push(subscription);
  }

  protected reflectHandlersEvents(handler: EventHandlerType<EventBase>): FunctionConstructor[] {
    return Reflect.getMetadata(EVENTS_HANDLER_METADATA, handler);
  }

  protected mapUnhandledExceptionEvent(eventOrCommand: IEvent | ICommand, exception: unknown): UnhandledExceptionInfo {
    return {
      cause: eventOrCommand,
      exception,
    };
  }
}
